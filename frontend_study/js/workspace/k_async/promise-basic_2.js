// promise의 원래 모습
// promise객체 생성시, callback함수를 전달 받고
// promise객체는 callback함수에 2개의 함수를 전달한다.
// function Promise(callback) {
//     callback(
//         //성공
//         function a() {
//             "성공";
//         },
//         //실패
//         function b() {
//             "실패";
//         }
//     );
// }

//==================================================================================
// // 콜백함수 안에는
// // 콜백함수의 인자인 a 메소드 : 밖에서 쓰고 싶은 값
// // 콜백함수에는 우리가 연산하거나 계산하고 싶은 것들을 작성해서 내보낸다.

// // promise 선언 부분 :
// const promise = new Promise((a) => {
//     // 콜백함수 안에서 이런 연산을 하게 되면 결과가 result에 저장되고 이 값을 밖에서 써야함.
//     let result = 1 + 1;
//     // 첫번째인자로 받은 a함수에 그 값을 전달해서 pormise 밖에서 쓸 수 있게 된다.
//     a(result);
// });

// // promise 사용하는 부분 : <==여기만 집중하고 이해하면됨!(return값이 담길 promise)
// // .then()함수와 같이 '어떻게 가져오지?'만 고민할 것!
// // 성공일때 쓰는 promise의 then함수를 통해 a함수의 값을 전달받아 올수있음.(a함수가 성공일때의 함수이므로)
// promise.then((result) => {
//     console.log(result);
// });

//==================================================================================
// ⭐promise 정리 (이것만 알고 가자)
// 1. promise 객체를 만드는 법
// 콜백함수 통해 2개의 함수를 가져올 준비하기(resolve(성공), reject(실패))
// - 콜백함수 내부의 결괏값을 그대로 쓸것이면 resolve(result);에 결괏값 전달하기.
// - 무슨 문제가 생겨서 콜백함수 내부의 결괏값을 그대로 안쓸것이면 reject();에 거절할때 전달할값 전달하기 .
const promise = new Promise((resolve) => {
    let result = 1 + 1;
    resolve(result);
});
// 2. 만들어진 promise 객체를 사용하는 법
// 그 result값은 promise의 then을 통해 resolve에 전달한것을 콜백함수로 받으면 된다!
promise.then((result) => {
    console.log(result); //3. promise안에서 작업한 결과가 외부에 전달되게 된다!
});
// 깊게 공부할 필요 없고 흐름만 알면된다.
// => 흐름 : promise는 콜백함수를 전달하도록 만들어졌다.
//           그 콜백함수가 받을 수 있는 인자는 함수고 , reolve와 reject다.(그 외 생략)
//           promise의 콜백함수 안에서 어떤 코드작업을 하게되면, 그 결과값이 나오고
//           그 결괏값을 resolve()함수에 담아 전달하면 promise 밖에서 then으로 가져올 수 있다.

// 바로 출력하려면 만들어진 log함수를 쓰면 됨
promise.then(console.log); //2

//==================================================================================
// ⭐비동기인 promise코드는 동기 코드와 흐름(처리하는 순서)이 다름(코드를 처리하는 엔진이 달라서.)
// - 동기를 처리하는 곳 : 콜스택(v8엔진) / 비동기 처리하는 곳 : libuv 라이브러리 = node.js서버
// - 비동기 처리기(libuv 라이브러리) 내부에 생명주기 존재 : 무한반복하는 이벤트 주기 <- promise객체가 수행될 곳
// - 하지만 promise객체도 무조건 콜스택에서 동기코드와 같이 동기적으로 수행되어야 함.
// - 그래서 콜스택의 코드가 먼저 처리된 후 비동기 코드 처리됨.
// - 비동기 처리기에 수행된 promise객체를 체크하는 객체가 존재.
// - 콜스택이 비었을때, 완료된 promise객체의 이행(reolve) or 거절(reject)가 콜스택으로 들어감.
// - 이 과정이 promise.then()

// 정리 :
// 1. 어떤게 비동기 코드인지 알기.
// 2. 코드 처리 순서 알기.
// 3. 동기와 비동기 코드를 섞어서 쓰면 안되겠구나를 깨닫기.
// * 하지만, js는 섞어쓸수 밖에 없음.-> 해결방법 -> 전부 비동기로 바꿨음.
//   동기와 비동기 코드 모두를 비동기환경으로 가져가서 모두 비동기로 처리하면
//   원하던 처리순서인 a->b->c가 가능해짐.

// 처리 구조 : 동기가 먼저 처리 된 후, 뒤에 있는 비동기가 처리가 되면 동기에 끼어 들어간다.(동기=>비동기)
// a - 동기(순서대로)
let data = 0;
// b - 비동기(순서x)
promise.then((result) => {
    data = result;
    console.log(`result:${result}`);
});
// c - 동기
console.log(`data : ${data}`);

// => 출력 순서 ( a -> c -> b)
// data : 0
// result:2

//================요기까지함 1:03 (day10)==================================================================
// promise를 쓰는 이유
// 1. 비동기라서
//    동기(콜스택,v8) ,비동기(libuv) => v8 + libuv = node
//    비동기와 동기는 섞어서 쓰면 안됨 => js는 같이 쓸수밖에 없음=>전부 비동기로 바꿔버림
// 2.서버 작업시 통신,DB에 접근하는 방식이 비동기방식이라서 JS로 비동기로 작업해야 함.
//   => 그 결과 값은 PROMISE객체
// 3.비동기끼리는 순서대로 작업됨

//동기 코드의 실행 흐름과 비동기 코드의 실행 흐름이 나뉘어있다.
//promise객체를 사용하는 이유는 Js로 통신 및 DB접근이 비동기로 되어있기 때문이다.
//이 때 비동기 코드의 결과가 promise객체에 담기기 때문에
//우리는 promise를 공부해야 한다.

async function test() {
    return 10;
}
console.log(test());
//Promise {[[PromiseState]]: 'fulfilled', [[PromiseResult]]: 10, Symbol(async_id_symbol): 11, Symbol(trigger_async_id_symbol): 1}
test().then((result) => {
    console.log(result);
}); //10
